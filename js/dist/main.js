/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_OnBrowserTextEditor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/OnBrowserTextEditor.js */ \"./js/src/OnBrowserTextEditor.js\");\n/* harmony import */ var _src_MappingStorageManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/MappingStorageManager.js */ \"./js/src/MappingStorageManager.js\");\n/* harmony import */ var _src_GamepadWatcher_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/GamepadWatcher.js */ \"./js/src/GamepadWatcher.js\");\n\n\n\n\nwindow.onload = function () {\n    document.body.style.fontSize = '16px'\n    if (gpConstants.useFadeOut) { timeValues.fpsCheck() }\n  }\n\n  // these are things needed to count a tick of rAF per second.\n  // in `gamepadDOMs.update` which is called in every tick,\n  // `timeValues.fpsIncrease` is called for 1 second.\n  // `timeValues.fpsCheck` is called on window load which stops\n  // counting after 1 second from loading.\n  var timeValues = {\n    fps: 0\n    , fpsChecked: false\n    , fpsIncrease: function () { timeValues.fps++ }\n    , fpsCheck: function () {\n      var o = setTimeout(function () {\n        timeValues.fpsChecked = true\n        clearTimeout(o)\n      }, 1000)\n    }\n  }\n\n  // for the 'in' keyword: I used the code below as a reference.\n  // https://github.com/luser/gamepadtest/blob/master/gamepadtest.js\n  var haveEvents = 'GamepadEvent' in window\n  var haveWebkitEvents = 'WebKitGamepadEvent' in window\n  var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame\n\n  // this will contain gamepad objects.\n  var gamepads = {}\n  if (gpConstants.useFadeOut) {\n    var gamepadTimestamps = {}\n\n    function gamepadTimestamp () {\n      var buttons = []\n      var axes = {}\n\n      this.buttonAdd = function () { buttons.push({t: 0, v: 0}) }\n      this.axisAdd = function (n) { axes[n] = {t: 0, v: 0} }\n\n      this.getButtonStatus = function (n) {\n        return buttons[n]\n      }\n      this.getAxisTimestamp = function (n) {\n        return axes[n].t\n      }\n\n      this.age = function () {\n        var max = timeValues.fps * gpConstants.fadeOutTime[gpConstants.fadeOutTime.length - 1]\n        for (var i = 0; i < buttons.length; i++) {\n          if (buttons[i].t < max) {\n            buttons[i].t++\n          }\n        }\n        for (a in axes) {\n          if (axes[a].t < max) {\n            axes[a].t++\n          }\n        }\n      }\n\n      // these 'update' functions tell if an input method is considered as 'touched'.\n      this.buttonUpdate = function (n, v) {\n        if (buttons[n].v !== v) {\n          buttons[n].t = 0\n          buttons[n].v = v\n          return true\n        } else {\n          return false\n        }\n      }\n      this.axisUpdate = function (n, v) {\n        // update the value always\n        axes[n].v = v\n        // check if the position is away enough from the center\n        // that the axis values is bigger than the deadzone\n        if (Math.abs(v) > gpConstants.axisDeadzone) {\n          axes[n].t = 0\n          return true\n        } else {\n          return false\n        }\n      }\n    }\n  }\n\n  var gamepadHandler = {\n    connect: function (e) {\n      gamepads[e.index] = e\n      console.log('connected: %d', e.index)\n      gamepadDOMs.add(e)\n    },\n    disconnect: function (index) {\n      console.log('disconnecting: %d', index)\n      gamepadDOMs.remove(index)\n      delete gamepads[index]\n    },\n    scan: function () {\n      var gamepadsFromNavigator = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [])\n      for (var i = 0; i < gamepadsFromNavigator.length; i++) {\n        if (gamepadsFromNavigator[i]) {\n          if (gamepadsFromNavigator[i].index in gamepads) {\n            gamepads[gamepadsFromNavigator[i].index] = gamepadsFromNavigator[i]\n          } else {\n            gamepadHandler.connect(gamepadsFromNavigator[i])\n          }\n        } else if ((gamepadsFromNavigator[i] === null || gamepadsFromNavigator[i] === undefined)\n          && document.getElementById(`gp${i}`)) {\n          gamepadHandler.disconnect(i)\n        }\n      }\n    }\n  }\n\n  var gamepadMapping = {\n    // XBox Pad (One, 360)\n    // Linux\n    'Microsoft Controller (STANDARD GAMEPAD Vendor: 045e Product: 02d1)': {\n      buttons: [\n        {name: 'A', type: 'button'}\n        , {name: 'B', type: 'button'}\n        , {name: 'X', type: 'button'}\n        , {name: 'Y', type: 'button'}\n        , {name: 'LB', type: 'button'}\n        , {name: 'RB', type: 'button'}\n        , {name: 'LT', type: 'button shoulder'}\n        , {name: 'RT', type: 'button shoulder'}\n        , {name: 'Se', type: 'button'}\n        , {name: 'St', type: 'button'}\n        , {name: 'L', type: 'button thumb'}\n        , {name: 'R', type: 'button thumb'}\n        , {name: '↑', type: 'button'}\n        , {name: '↓', type: 'button'}\n        , {name: '←', type: 'button'}\n        , {name: '→', type: 'button'}\n        , {name: 'ⓧ', type: 'button'}\n      ]\n      , axes: [\n        {name: 'L', type: 'thumb'}\n        , {name: 'L', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n      ]\n    }\n    // Windows\n    , 'Xbox 360 Controller (XInput STANDARD GAMEPAD)': {\n      buttons: [\n        {name: 'A', type: 'button'}\n        , {name: 'B', type: 'button'}\n        , {name: 'X', type: 'button'}\n        , {name: 'Y', type: 'button'}\n        , {name: 'LB', type: 'button'}\n        , {name: 'RB', type: 'button'}\n        , {name: 'LT', type: 'button'}\n        , {name: 'RT', type: 'button'}\n        , {name: 'Se', type: 'button'}\n        , {name: 'St', type: 'button'}\n        , {name: 'L', type: 'button thumb'}\n        , {name: 'R', type: 'button thumb'}\n        , {name: '⏶', type: 'button'}\n        , {name: '⏷', type: 'button'}\n        , {name: '⏴', type: 'button'}\n        , {name: '⏵', type: 'button'}\n      ]\n      , axes: [\n        {name: 'L', type: 'thumb'}\n        , {name: 'L', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n      ]\n    }\n    , 'xinput': {\n      buttons: [\n        {name: 'A', type: 'button'}\n        , {name: 'B', type: 'button'}\n        , {name: 'X', type: 'button'}\n        , {name: 'Y', type: 'button'}\n        , {name: 'LB', type: 'button'}\n        , {name: 'RB', type: 'button'}\n        , {name: 'LT', type: 'button'}\n        , {name: 'RT', type: 'button'}\n        , {name: 'Se', type: 'button'}\n        , {name: 'St', type: 'button'}\n        , {name: 'L', type: 'button thumb'}\n        , {name: 'R', type: 'button thumb'}\n        , {name: '⏶', type: 'button'}\n        , {name: '⏷', type: 'button'}\n        , {name: '⏴', type: 'button'}\n        , {name: '⏵', type: 'button'}\n      ]\n      , axes: [\n        {name: 'L', type: 'thumb'}\n        , {name: 'L', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n      ]\n    }\n\n    // DualShock4\n    // Windows\n    , 'Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 05c4)': {\n      buttons: [\n        {name: 'X', type: 'button'}\n        , {name: '◯', type: 'button'}\n        , {name: '□', type: 'button'}\n        , {name: 'Δ', type: 'button'}\n        , {name: 'L1', type: 'button'}\n        , {name: 'R1', type: 'button'}\n        , {name: 'L2', type: 'button'}\n        , {name: 'R2', type: 'button'}\n        , {name: 'Sh', type: 'button'}\n        , {name: 'Op', type: 'button'}\n        , {name: 'L', type: 'button thumb'}\n        , {name: 'R', type: 'button thumb'}\n        , {name: '⏶', type: 'button'}\n        , {name: '⏷', type: 'button'}\n        , {name: '⏴', type: 'button'}\n        , {name: '⏵', type: 'button'}\n        , {name: 'PS', type: 'button'}\n        , {name: 'TP', type: 'button'}\n      ]\n      , axes: [\n        {name: 'L', type: 'thumb'}\n        , {name: 'L', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n      ]\n    }\n    , 'Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 09cc)': {\n      buttons: [\n        {name: 'X', type: 'button'}\n        , {name: '◯', type: 'button'}\n        , {name: '□', type: 'button'}\n        , {name: 'Δ', type: 'button'}\n        , {name: 'L1', type: 'button'}\n        , {name: 'R1', type: 'button'}\n        , {name: 'L2', type: 'button'}\n        , {name: 'R2', type: 'button'}\n        , {name: 'Sh', type: 'button'}\n        , {name: 'Op', type: 'button'}\n        , {name: 'L', type: 'button thumb'}\n        , {name: 'R', type: 'button thumb'}\n        , {name: '⏶', type: 'button'}\n        , {name: '⏷', type: 'button'}\n        , {name: '⏴', type: 'button'}\n        , {name: '⏵', type: 'button'}\n        , {name: 'PS', type: 'button'}\n        , {name: 'TP', type: 'button'}\n      ]\n      , axes: [\n        {name: 'L', type: 'thumb'}\n        , {name: 'L', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n      ]\n    }\n    , 'Sony Interactive Entertainment Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 09cc)': {\n      buttons: [\n        {name: 'X', type: 'button'}\n        , {name: '◯', type: 'button'}\n        , {name: '□', type: 'button'}\n        , {name: 'Δ', type: 'button'}\n        , {name: 'L1', type: 'button'}\n        , {name: 'R1', type: 'button'}\n        , {name: 'L2', type: 'button'}\n        , {name: 'R2', type: 'button'}\n        , {name: 'Sh', type: 'button'}\n        , {name: 'Op', type: 'button'}\n        , {name: 'L', type: 'button thumb'}\n        , {name: 'R', type: 'button thumb'}\n        , {name: '⏶', type: 'button'}\n        , {name: '⏷', type: 'button'}\n        , {name: '⏴', type: 'button'}\n        , {name: '⏵', type: 'button'}\n        , {name: 'PS', type: 'button'}\n        , {name: 'TP', type: 'button'}\n      ]\n      , axes: [\n        {name: 'L', type: 'thumb'}\n        , {name: 'L', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n        , {name: 'R', type: 'thumb'}\n      ]\n    }\n  }\n\n  var gamepadDOMs = {\n    add: function (gp) {\n      if (gp.id.indexOf('Unknown Gamepad') !== -1) return\n      var isLinuxXpad = gp.id === 'Microsoft Controller (STANDARD GAMEPAD Vendor: 045e Product: 02d1)'\n      if (gpConstants.useFadeOut) {\n        // create a couple of arrays for tracking button's timestamp\n        gamepadTimestamps[gp.index] = new gamepadTimestamp()\n        var gts = gamepadTimestamps[gp.index]\n      }\n\n      // create dom for a gamepad\n      var d = document.createElement('div')\n      d.setAttribute('id', `gp${gp.index}`)\n      d.setAttribute('class', gp.id)\n\n      // create dom for buttons\n      var b = document.createElement('div')\n      b.setAttribute('class', 'buttons')\n      for (var i = 0; i < gp.buttons.length; i++) {\n        if (gamepadMapping[gp.id]) {\n          var cur = gamepadMapping[gp.id].buttons[i]\n          var e = document.createElement('span')\n          if (cur) {\n            if (cur.type === 'button thumb') {} else {\n              e.setAttribute('class', cur.type)\n              e.innerHTML = cur.name\n            }\n          }\n        } else {\n          var e = document.createElement('span')\n          e.setAttribute('class', 'button')\n          e.innerHTML = i\n        }\n        e.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`\n        e.style.transition = `opacity ${gpConstants.fadeOutDuration}s`\n        b.appendChild(e)\n        if (gpConstants.useFadeOut) { gts.buttonAdd() }\n      }\n      d.appendChild(b)\n\n      // create dom for axes\n      var a = document.createElement('div')\n      a.setAttribute('class', 'axes')\n      var c // c resides in e and represent the position of thumb stick.\n      for (i = 0; i < gp.axes.length; i++) {\n        if (gamepadMapping[gp.id]) {\n          var cur = gamepadMapping[gp.id].axes[i]\n          if (cur.type === 'thumb') {\n            if (a.getElementsByClassName(`axis ${cur.name}`).length) {\n              c.style.top = `${gpConstants.thumbSize / 2}%`\n            } else {\n              e = document.createElement('span')\n              e.setAttribute('class', `axis ${cur.name}`)\n              c = document.createElement('span')\n              c.style.width = `${gpConstants.thumbSize}%`\n              c.style.height = `${gpConstants.thumbSize}%`\n              c.style.left = `${gpConstants.thumbSize / 2}%`\n              e.style.borderColor = gpConstants.defaultColor\n              e.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`\n              e.style.transition = `opacity ${gpConstants.fadeOutDuration}s`\n              e.appendChild(c)\n              a.appendChild(e)\n              if (gpConstants.useFadeOut) { gts.axisAdd(cur.name) }\n            }\n          } else if (cur.type.match('button')) {\n            e = document.createElement('span')\n            e.setAttribute('class', cur.type)\n            if (isLinuxXpad) {\n              if (cur.type.match('shoulder')) {\n                e.innerHTML = cur.name\n              } else if (cur.type.match('polar')) {\n                // linux accepts dpad LR and dpad UD through\n                // 6th and 7th axes respectively.\n                e.innerHTML = i === 6 ? 'R' : 'D'\n                var e2 = e.cloneNode(false)\n                e2.innerHTML = i === 6 ? 'L' : 'U'\n                e2.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`\n                e2.style.transition = `opacity ${gpConstants.fadeOutDuration}s`\n                b.appendChild(e2)\n                if (gpConstants.useFadeOut) { gts.buttonAdd() }\n              }\n            }\n            e.style.filter = `hue-rotate(${gpConstants.pressedButtonBackgroundColorHue}deg)`\n            e.style.transition = `opacity ${gpConstants.fadeOutDuration}s`\n            b.appendChild(e)\n            if (gpConstants.useFadeOut) { gts.buttonAdd() }\n          }\n        } else {\n          e = document.createElement('span')\n          e.setAttribute('class', 'axis')\n          e.innerHTML = `${i} `\n          a.appendChild(e)\n        }\n      }\n      d.appendChild(a)\n\n      // attach gamepad dom to the document\n      document.body.appendChild(d)\n    },\n    remove: function (index) {\n      var d = document.getElementById(`gp${index}`)\n      document.body.removeChild(d)\n      delete gamepadTimestamps[index]\n    },\n    update: function () {\n      gamepadHandler.scan()\n      if (gpConstants.useFadeOut && !timeValues.fpsChecked) {\n        timeValues.fpsIncrease()\n      }\n      for (j in gamepads) {\n        var gp = gamepads[j]\n        if (gp.id.indexOf('Unknown Gamepad') !== -1) continue\n        var isLinuxXpad = gp.id === 'Microsoft Controller (Vendor: 045e Product: 02d1)'\n        if (gpConstants.useFadeOut) {\n          var gts = gamepadTimestamps[gp.index]\n          gts.age()\n        }\n        var d = document.getElementById(`gp${gp.index}`)\n\n        var b = d.getElementsByClassName('buttons')[0]\n        for (var i = 0; i < gp.buttons.length; i++) {\n          var e\n          var es = gp.buttons[i] // each status of buttons\n          var val = 100 * es.value\n          if (gamepadMapping[gp.id]) {\n            var cur = gamepadMapping[gp.id].buttons[i]\n          }\n          if (cur && cur.type === 'button thumb') {\n            e = d.getElementsByClassName(`axis ${cur.name}`)[0].children[0]\n            if (val === 100) {\n              e.style.background = 'url(dot.png)'\n            } else {\n              e.style.background = gpConstants.defaultColor\n            }\n            // gamepadDOMs.opacityControl(\n            // \tgts.buttonUpdate(i, val),\n            // \tgts.getButtonStatus(i),\n            // \te\n            // );\n          } else {\n            e = b.children[i] // each dom for buttons\n            e.style.backgroundSize = `100% ${val}%`\n            e.style.color = val ? gpConstants.pressedButtonColor : gpConstants.defaultColor\n            if (gpConstants.useFadeOut) {\n              gamepadDOMs.opacityControl(\n                gts.buttonUpdate(i, val),\n                gts.getButtonStatus(i),\n                e\n              )\n            }\n          }\n        }\n\n        var a\n        for (i = 0; i < gp.axes.length; i++) {\n          if (gamepadMapping[gp.id]) {\n            var cur = gamepadMapping[gp.id].axes[i]\n            var val = gp.axes[i]\n            if (cur.type === 'thumb') {\n              a = d.getElementsByClassName(`axis ${cur.name}`)[0].children[0]\n              var thumbMargin = (100 - gpConstants.thumbSize) / 2\n\n              // in Windows, axis0~4 is LeftThumbXY and RightThumbXY.\n              // so I made it so if i is even it should be treated\n              // as Y value.\n              // in Linux, though, these XY values are 0, 1 and 3, 4.\n              // I made my code bit dirty by\n              // simply swapping i values just before\n              // converting gamepad's value to the top and left value.\n              var linuxXpadCalibration = isLinuxXpad && (i === 3 || i === 4)\n                if (linuxXpadCalibration) {\n                    i === 3 ? i = 4 : i = 3\n                }\n                if (i % 2) {\n                    if (linuxXpadCalibration) {\n                        i === 3 ? i = 4 : i = 3\n                    }\n                    a.style.top = `${thumbMargin + thumbMargin * val}%`\n                } else {\n                    if (linuxXpadCalibration) {\n                        i === 3 ? i = 4 : i = 3\n                    }\n                    a.style.left = `${thumbMargin + thumbMargin * val}%`\n                }\n              \n              if (gpConstants.useFadeOut) {\n                gamepadDOMs.opacityControl(\n                  gts.axisUpdate(cur.name, val),\n                  gts.getAxisTimestamp(cur.name),\n                  a.parentElement\n                )\n              }\n            } else if (cur.type.match('button')) {\n              if (isLinuxXpad) {\n                var buttonNumber\n                if (cur.type.match('shoulder')) {\n                  buttonNumber = i === 2 ? 11 : 12\n                  e = b.children[buttonNumber]\n                  val = 50 + Math.floor(50 * val)\n                  if (val) {\n                    e.style.color = gpConstants.pressedButtonColor\n                  } else {\n                    e.style.color = gpConstants.defaultColor\n                  }\n                  e.style.backgroundSize = `100% ${val}%`\n                  if (gpConstants.useFadeOut) {\n                    gamepadDOMs.opacityControl(\n                      gts.buttonUpdate(buttonNumber, val),\n                      gts.getButtonStatus(buttonNumber),\n                      e\n                    )\n                  }\n                } else if (cur.type.match('polar')) {\n                  var dpadX = i === 6\n                  var currentMinusPolarButton = dpadX ? 13 : 15\n                  var currentPlusPolarButton = dpadX ? 14 : 16\n                  buttonNumber\n                    = val > 0 ? currentPlusPolarButton\n                    : val < 0 ? currentMinusPolarButton\n                      : 0\n                  val = Math.abs(100 * val)\n                  if (buttonNumber) {\n                    e = b.children[buttonNumber]\n                    e.style.backgroundSize = `100% ${val}%`\n                    e.style.color = gpConstants.pressedButtonColor\n                  } else {\n                    e = b.children[currentMinusPolarButton]\n                    e.style.backgroundSize\n                      = e.nextSibling.style.backgroundSize\n                      = '100% 0%'\n                    e.style.color\n                      = e.nextSibling.style.color\n                      = gpConstants.defaultColor\n                  }\n                  if (gpConstants.useFadeOut) {\n                    if (buttonNumber) {\n                      gamepadDOMs.opacityControl(\n                        gts.buttonUpdate(buttonNumber, val),\n                        gts.getButtonStatus(buttonNumber),\n                        e\n                      )\n                    } else {\n                      gamepadDOMs.opacityControl(\n                        gts.buttonUpdate(currentMinusPolarButton, 0),\n                        gts.getButtonStatus(currentMinusPolarButton),\n                        b.children[currentMinusPolarButton]\n                      )\n                      gamepadDOMs.opacityControl(\n                        gts.buttonUpdate(currentPlusPolarButton, 0),\n                        gts.getButtonStatus(currentPlusPolarButton),\n                        b.children[currentPlusPolarButton]\n                      )\n                    }\n                  }\n                }\n              }\n            }\n          } else {\n            var a = d.getElementsByClassName('axis')\n            e = a[i]\n            e.innerHTML = `${i}${gp.axes[i].toFixed(2)} `\n          }\n        }\n\n      }\n      rAF(gamepadDOMs.update)\n    }\n    , opacityControl: function (isChanged, status, element) {\n      if (element) {\n        // button's status will be passed as {timestamp, value}.\n        // axis' status will be passed as timestamp,\n        // and then converted to {timestamp, value=0}.\n        if (typeof status === 'number') {\n          status = {t: status, v: 0}\n        }\n        if (isChanged || status.v) {\n          element.style.transition = 'opacity 0s'\n          element.style.opacity = 1\n          var si = setInterval(function () {\n            element.style.transition = `opacity ${gpConstants.fadeOutDuration}s`\n            clearInterval(si)\n          }, 1)\n        } else {\n          var ts = status.t / timeValues.fps\n          // this for loop breaks after checking the last condition fitting, don't need to put a condition to prevent it from keep running.\n          for (var k = gpConstants.fadeOutTime.length - 1; k >= 0; k--) {\n            if (ts >= gpConstants.fadeOutTime[k]) {\n              element.style.opacity = 1 - gpConstants.fadeOutStrength[k]\n              break\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // ignite the gamepad update loop.\n  rAF(gamepadDOMs.update)\n\n  if (haveEvents) {\n    window.addEventListener('gamepadconnected', function (e) {\n      gamepadHandler.connect(e.gamepad)\n    })\n    window.addEventListener('gamepaddisconnected', function (e) {\n      gamepadHandler.disconnect(e.gamepad)\n    })\n  } else if (haveWebkitEvents) {\n    window.addEventListener('webkitgamepadconnected', function (e) {\n      gamepadHandler.connect(e.gamepad)\n    })\n    window.addEventListener('webkitgamepaddisconnected', function (e) {\n      gamepadHandler.disconnect(e.gamepad)\n    })\n  } else {\n    var scanningWithNoEvents = setInterval(gamepadHandler.scan, 500)\n  }\n\n//# sourceURL=webpack:///./js/main.js?");

/***/ }),

/***/ "./js/src/GamepadWatcher.js":
/*!**********************************!*\
  !*** ./js/src/GamepadWatcher.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GamepadWatcher; });\n/* eslint-disable no-unused-vars */\n/**\n * @typedef {Object} GamepadList\n * @property {(GamePad|null)} 0\n * @property {(GamePad|null)} 1\n * @property {(GamePad|null)} 2\n * @property {(GamePad|null)} 3\n * @property {number} length\n */\n/**\n * @typedef {Object} GamePad\n * @property {number[]} axes\n * @property {GamepadButton[]} buttons\n * @property {boolean} connected\n * @property {string} id\n * @property {number} index\n * @property {string} mapping\n * @property {number} timestamp\n */\n/**\n * @typedef {Object} GamepadButton\n * @property {boolean} pressed\n * Tells if the button is pressed.\n * @property {number} value\n * State of the button. 0 when not pressed, 1 when fully pressed.\n * Can be a number between 0 and 1 if the button is an analog kind.\n */\n\n/**\n * watch gamepad connections,\n * adjust updating interval in relation to the present of connected gamepads,\n * execute a callback for every frame or update moments\n */\nclass GamepadWatcher {\n  /**\n   * create a watcher.\n   *\n   * @param {function} updateCallback Callback to execute for every frame or updates.\n   * @param {boolean} [logMessage=false] emits to console for every loop event.\n   * @param {number} [pollInterval=2000] Interval to check the gamepads when none was found before.\n   */\n  constructor (updateCallback, logMessage = false, pollInterval = 2000) {\n    // `gamepadID` only contains the obtained ID of each gamepads.\n    this.gamepadID = {}\n    this.pollInterval = pollInterval\n    this.updateAtEveryFrame = false\n    this.updateID = 0\n    this.flushUpdateID = function () {\n      if (this.updateID) {\n        clearInterval(this.updateID)\n      }\n      this.updateID = 0\n    }\n    this.logMessage = logMessage\n    if (updateCallback) {\n      this.update = updateCallback\n    }\n    this.pollGamepads()\n  }\n\n  /**\n   * Unless it's recognized as a general XInput controller, which has no explicit ID, get an ID of a gamepad.\n   *\n   * ID format is different for two browsers:\n   * `/([0-9a-f]{1,4})-/g` in Firefox,\n   * `/([0-9a-f]{4})/g` in Chrome.\n   *\n   * @example\n   * Firefox 54c-5c4-Wireless Controller\n   * Chrome  Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 05c4)\n   *\n   * @param {GamePad} gamepadObj The gamepad object to find the ID of.\n   *\n   * @return {(String|boolean)} the hex part of the ID concatenated in a string, if not found then `false`. If it's a general XInput controller it's simply `XInput`.\n   */\n  static getGamepadID (gamepadObj) {\n    const isGeneralXInput = gamepadObj.id.match(/xinput/i)\n    if (isGeneralXInput) {\n      return 'XInput'\n    }\n\n    const idPattern = /([0-9a-f]{4})/g\n\n    const matches = gamepadObj.id.match(idPattern)\n    if (matches.length !== 2) {\n      return false\n    }\n\n    // concatenate the hex part to return the 8 letters from the ID.\n    return matches.reduce(\n      (pv, cv) => pv + (cv.replace(/[^0-9a-f]/, '')).padStart(4, '0'),\n      ''\n    )\n  }\n  \n  /**\n   * tell if any gamepads exist.\n   * @param {GamepadList} list if GamepadList is already retrieved, you can manually put it as the parameter here.\n   *\n   * @returns {boolean}\n   */\n  static gamepadsExist (list = navigator.getGamepads()) {\n    return Object.values(list)\n      .filter(v => v !== null)\n     .length !== 0\n  }\n\n  /**\n   * return GamepadList if any gamepads exist, otherwise return false.\n   *\n   * @returns {(GamepadList|boolean)}\n   */\n  static getGamepadsIfFound () {\n    const rawGamepads = navigator.getGamepads()\n\n    return this.gamepadsExist(rawGamepads) ? rawGamepads : false\n  }\n\n  /**\n   * check if any gamepads exist and manage update loops.\n   *\n   * Keeps the loop and does nothing if a poll loop is already running.\n   * Repeats until a gamepad is found, at which it stops the poll loop and initiates animation loop (repeats inside `refresh`).\n   */\n  pollGamepads () {\n    if (GamepadWatcher.gamepadsExist()) {\n      // stop the poll loop, initiate refresh loop\n      // this will start the animation loop at the end of `refresh`\n      this.flushUpdateID()\n      this.updateAtEveryFrame = true\n      if (this.logMessage) { console.info('Gamepad is found. Now updating in every frame.') }\n      this.refresh()\n    } else {\n      if (this.updateAtEveryFrame) {\n        // stop animation loop if there's any\n        window.cancelAnimationFrame(this.updateID)\n        this.flushUpdateID()\n        this.updateAtEveryFrame = false\n        if (this.logMessage) { console.info('No gamepads left. Now polling.') }\n      }\n      // start the poll loop if there's no any already\n      if (!this.updateID) {\n        this.updateID = setInterval(\n          this.pollGamepads.bind(this), this.pollInterval\n        )\n        if (this.logMessage) { console.info('Started polling.') }\n      }\n      if (this.logMessage) { console.info('Waiting for a gamepad.') }\n    }\n  }\n\n  /**\n   * add index and gamepadID of the gamepad to `gamepadID` array.\n   *\n   * @param {Gamepad} gamepadObj\n   */\n  register (gamepadObj) {\n    this.gamepadID[gamepadObj.index] =\n      GamepadWatcher.getGamepadID(gamepadObj)\n    if (this.logMessage) { console.info('gamepad found:', gamepadObj.index) }\n  }\n\n  /**\n   * remove index from the `gamepadID` array.\n   *\n   * @param {number} gamepadIndex\n   */\n  unregister (gamepadIndex) {\n    delete this.gamepadID[gamepadIndex]\n    if (this.logMessage) { console.info('gamepad lost:', gamepadIndex) }\n  }\n\n  /**\n   * scans connected gamepads and update indexes in `gamepadID` array.\n   * call `update()` method for each frame.\n   * if no gamepad is found, stop the animation frame loop and initiate poll loop.\n   */\n  refresh () {\n    let rawGamepads = GamepadWatcher.getGamepadsIfFound()\n\n    // no gamepads found, start poll loop.\n    if (!rawGamepads) {\n      for (let index in this.gamepadID) {\n        if (this.gamepadID.hasOwnProperty(index)) {\n          this.unregister(parseInt(index))\n        }\n      }\n      this.pollGamepads()\n      return\n    }\n\n    for (let index = 0; index < rawGamepads.length; index++) {\n      // add gamepad information to the array.\n      if (rawGamepads[index] && !this.gamepadID[index]) {\n        this.register(rawGamepads[index])\n      }\n      // remove gamepad information from the array.\n      if (this.gamepadID[index] && !rawGamepads[index]) {\n        this.unregister(index)\n      }\n    }\n\n    this.update(rawGamepads)\n\n    window.requestAnimationFrame(this.refresh.bind(this))\n  }\n}\n\n\n//# sourceURL=webpack:///./js/src/GamepadWatcher.js?");

/***/ }),

/***/ "./js/src/MappingStorageManager.js":
/*!*****************************************!*\
  !*** ./js/src/MappingStorageManager.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MappingStorageManager; });\n/* eslint-disable no-unused-vars */\n/* eslint-disable no-undef */\n/**\n * @typedef {Object} gamepadMapping\n * @property {String} identifier human readable string to tell what this mapping is for\n * @property {?Object} windows set of buttons and axes used in Windows, should exist if the mapping is used on Windows.\n * @property {{label: String, type: String}[]} windows.buttons\n * @property {{label: String, type: String}[]} windows.axes\n * @Property {?Object} linux set of buttons and axes used in Linux, should exist if the mapping is used on Linux.\n * @property {{label: String, type: String}[]} linux.buttons\n * @property {{label: String, type: String}[]} linux.axes\n */\n/**\n * @typedef {string} gamepadId 8-digit hexadecimal string\n */\n\nclass MappingStorageManager {\n  /**\n   * @param {?gamepadMapping[]} newMappings all mappings to store on the computer\n   */\n  constructor (newMappings) {\n    this.platform = undefined\n    this.decidePlatform()\n    if (newMappings && typeof newMappings === 'object') {\n      this.mappings = newMappings\n      this.store()\n    } else {\n      this.load()\n    }\n  }\n\n  /* I assume OBS is used on either Windows or Linux,\n  and since `navigator.platform` values for Windows are in a common pattern,\n  I will check if it's Windows or not. */\n  decidePlatform () {\n    this.platform =\n      navigator.platform.match(/^Win/) ? 'Windows' : 'Linux'\n  }\n  \n  add (gamepadId, mappingObj) {\n    this.mappings[gamepadId] = mappingObj\n  }\n  \n  remove (gamepadId) {\n    delete this.mappings[gamepadId]\n  }\n\n  store () {\n    if (\n      Object.keys(this.mappings).length === 0 &&\n      this.mappings.constructor === Object\n    ) {} else {\n      window.localStorage.setItem('mappings', this.mappings)\n      console.info(`Mapping stored: ${window.localStorage.getItem('mappings')}`)\n    }\n  }\n\n  load () {\n    this.mappings = window.localStorage.getItem('mappings') || {}\n    console.info(`Mapping loaded: ${this.mappings}`)\n  }\n}\n\n\n//# sourceURL=webpack:///./js/src/MappingStorageManager.js?");

/***/ }),

/***/ "./js/src/OnBrowserTextEditor.js":
/*!***************************************!*\
  !*** ./js/src/OnBrowserTextEditor.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return OnBrowserTextEditor; });\n/**\n * @typedef {Object} TextEditorCallbacks\n * @property {callback} save function to call when user tries to save\n * @property {callback} load function to clal when user tries to load\n */\n/**\n * @typedef {Object} TextEditorDOM\n * @property {HTMLElement} wrapper a div wrapping all the elements\n * @property {HTMLTextAreaElement} textarea\n * @property {HTMLElement} notifyArea\n * @property {HTMLButtonElement} saveButton\n * @property {HTMLButtonElement} loadButton\n */\n\n/**\n * Create a textarea and a set of buttons to give access to the text\n * @class\n */\nclass OnBrowserTextEditor {\n  /** @param {TextEditorCallbacks} callbacks */\n  constructor (callbacks) {\n    this.textarea = document.createElement('textarea')\n    this.notifyArea = document.createElement('div')\n    this.notifyArea.setAttribute('id', 'notify-area')\n    this.saveButton = document.createElement('button')\n    this.saveButton.setAttribute('class', 'save-button')\n    this.saveButton.textContent =\n      'Save Current Text as Configuration'\n    this.loadButton = document.createElement('button')\n    this.loadButton.setAttribute('class', 'load-button')\n    this.loadButton.textContent =\n      'Load Current Configuration'\n    \n    /**\n     * gives the text in the textarea for the callback in the parameter to do the job.\n     * In cases where the user should be notified, `notify` can accept messages.\n     *\n     * @example\n     * callbacks.save = (text, notify) => {\n     *   try {\n     *     textarea.value = window.localStorage.setItem('text')\n     *   } catch (e) {\n     *     notify({text: \"There's an error.\", isError: true})\n     *   }\n     * }\n     */\n    this.save = () =>\n      callbacks.save(this.textarea.value, this.notify)\n    /**\n     * gives the textarea for the callback in the parameter to do the job.\n     * In cases where the user should be notified, `notify` can accept messages.\n     *\n     * @example\n     * callbacks.load = (textarea, notify) => {\n     *   try {\n     *     textarea.value = window.localStorage.getItem('text')\n     *   } catch (e) {\n     *     notify({text: \"There's an error.\", isError: true})\n     *   }\n     * }\n     */\n    this.load = () =>\n      callbacks.load(this.textarea, this.notify)\n    \n    this.saveButton.onclick = this.save.bind(this)\n    this.loadButton.onclick = this.load.bind(this)\n    \n    this.notifyID = 0\n    /**\n     * accepts the message info and change the notification area class name for a brief time.\n     *\n     * @param {{text: String, isError: boolean}} message\n     */\n    this.notify = message => {\n      const classNames =\n        `visible${message.isError ? ' error' : ''}`\n      this.notifyArea.setAttribute('class', classNames)\n      this.notifyArea.innerText = message.text\n      if (this.notifyID) {\n        clearTimeout(this.notifyID)\n      }\n      this.notifyID = setTimeout(area => {\n        area.setAttribute('class', 'hidden')\n        area.innerText = ''\n      }, 4000, this.notifyArea)\n    }\n  \n    this.wrapper = document.createElement('div')\n    this.wrapper.setAttribute('id', 'text-editor-wrapper')\n    this.wrapper.appendChild(this.textarea)\n    this.wrapper.appendChild(this.notifyArea)\n    this.wrapper.appendChild(this.saveButton)\n    this.wrapper.appendChild(this.loadButton)\n  }\n  \n  /**\n   * @returns {TextEditorDOM} the page then can use these elements\n   */\n  getDOM () {\n    return {\n      wrapper: this.wrapper,\n      textarea: this.textarea,\n      notifyArea: this.notifyArea,\n      saveButton: this.saveButton,\n      loadButton: this.loadButton\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./js/src/OnBrowserTextEditor.js?");

/***/ })

/******/ });